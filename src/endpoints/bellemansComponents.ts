/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useBellemansContext,
  BellemansContext,
  queryKeyFn,
} from "./bellemansContext";
import { deepMerge } from "./bellemansUtils";
import type * as Fetcher from "./bellemansFetcher";
import { bellemansFetch } from "./bellemansFetcher";
import type * as Schemas from "./bellemansSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type PagesGetAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type PagesGetAllVariables = BellemansContext["fetcherOptions"];

export const fetchPagesGetAll = (
  variables: PagesGetAllVariables,
  signal?: AbortSignal,
) =>
  bellemansFetch<
    Schemas.GetAllPagesResponse,
    PagesGetAllError,
    undefined,
    {},
    {},
    {}
  >({ url: "/pages", method: "get", ...variables, signal });

export function pagesGetAllQuery(variables: PagesGetAllVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.GetAllPagesResponse>;
};

export function pagesGetAllQuery(
  variables: PagesGetAllVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.GetAllPagesResponse>)
    | reactQuery.SkipToken;
};

export function pagesGetAllQuery(
  variables: PagesGetAllVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/pages",
      operationId: "pagesGetAll",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchPagesGetAll(variables, signal),
  };
}

export const useSuspensePagesGetAll = <TData = Schemas.GetAllPagesResponse,>(
  variables: PagesGetAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllPagesResponse,
      PagesGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBellemansContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.GetAllPagesResponse,
    PagesGetAllError,
    TData
  >({
    ...pagesGetAllQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePagesGetAll = <TData = Schemas.GetAllPagesResponse,>(
  variables: PagesGetAllVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetAllPagesResponse,
      PagesGetAllError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBellemansContext(options);
  return reactQuery.useQuery<
    Schemas.GetAllPagesResponse,
    PagesGetAllError,
    TData
  >({
    ...pagesGetAllQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type PagesGetByIdPathParams = {
  name: string;
};

export type PagesGetByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ProblemDetails;
}>;

export type PagesGetByIdVariables = {
  pathParams: PagesGetByIdPathParams;
} & BellemansContext["fetcherOptions"];

export const fetchPagesGetById = (
  variables: PagesGetByIdVariables,
  signal?: AbortSignal,
) =>
  bellemansFetch<
    Schemas.GetPageByNameResponse,
    PagesGetByIdError,
    undefined,
    {},
    {},
    PagesGetByIdPathParams
  >({ url: "/pages/{name}", method: "get", ...variables, signal });

export function pagesGetByIdQuery(variables: PagesGetByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.GetPageByNameResponse>;
};

export function pagesGetByIdQuery(
  variables: PagesGetByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.GetPageByNameResponse>)
    | reactQuery.SkipToken;
};

export function pagesGetByIdQuery(
  variables: PagesGetByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/pages/{name}",
      operationId: "pagesGetById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchPagesGetById(variables, signal),
  };
}

export const useSuspensePagesGetById = <TData = Schemas.GetPageByNameResponse,>(
  variables: PagesGetByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetPageByNameResponse,
      PagesGetByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBellemansContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.GetPageByNameResponse,
    PagesGetByIdError,
    TData
  >({
    ...pagesGetByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePagesGetById = <TData = Schemas.GetPageByNameResponse,>(
  variables: PagesGetByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetPageByNameResponse,
      PagesGetByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBellemansContext(options);
  return reactQuery.useQuery<
    Schemas.GetPageByNameResponse,
    PagesGetByIdError,
    TData
  >({
    ...pagesGetByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/pages";
      operationId: "pagesGetAll";
      variables: PagesGetAllVariables | reactQuery.SkipToken;
    }
  | {
      path: "/pages/{name}";
      operationId: "pagesGetById";
      variables: PagesGetByIdVariables | reactQuery.SkipToken;
    };
